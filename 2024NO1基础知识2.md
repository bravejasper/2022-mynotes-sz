### day1

#### 1.类和对象

##### 1.定义一个类

格式

```
修饰符 class 类名{
    //类中的五大成分。
    1.成员变量（属性）
    2.成员方法 (行为。无static，自定义方法+get、set方法) 
    3.构造器 （初始化类的对象数据的。构造方法）
    4.内部类（后续补充）
    5.代码块
}
```



#### 2.继承（有内存图）

格式：

```
修饰符 class 子类名 extends 父类名{

}
```



![1713602081050](Typoraphoto/1713602081050.png)



#### 3.一个文件可以定义多个类

注意：

1.该文件中只能有一个public修饰的类
2.public修饰的类的类名必须和文件名一致
3.开发中,一般是一个类对应一个文件



#### 4.继承后成员访问规则

##### 1.构造方法

子类构造方法用super调用（空参构造可直接访问）

##### 2.私有成员

①私有成员变量

set、get方法

②私有成员方法

父类公共方法间接访问

##### 3.非私有成员

直接访问



#### 5.方法重写

子类中出现与父类一模一样的方法（返回值类型，方法名和参数列表都相同）。

注意事项：

1.父子类关系

2.概念

3.子类方法重写父类方法，必须权限大于父类权限

public >  protected  > (默认) > private

4.加上@Override注解，检验是否重写成功，重写注解校验（提高代码的可读性）。



方法重载：

在同一个类中，出现多个同名的方法，仅参数列表不同，与其他无关。



#### 6.关键字this、super

##### 1.this

访问本类的成员属性、成员方法、构造方法（this（实参））

注意：

1.this调用本类的构造方法必须放在构造方法的第一行
2.两个本类的构造方法不能使用this相互调用

##### 2.super

访问父类的成员属性（super.父类成员变量）、成员方法（super.成员方法名（实参））、构造方法（super（实参））

注意：

1.super访问父类的构造方法一定要放在子类构造方法的第一行
2.子类构造方法默认会调用父类的空参构造方法
3.在子类构造方法中调用父类的构造方法,其实就是为了初始化从父类继承过来的属性



#### 7.抽象类

使用abstract关键字修饰的类就是抽象类，没有方法体（直接；分号收尾）。

格式：修饰符  abstract  class  类名{  }

成员：

1.成员变量

2.成员方法

3.构造方法

4.抽象方法

①格式：修饰符  abstract  返回值类型  方法名(形参列表)；

②不是必须有，但有抽象方法的类一定是抽象类（不过抽象类中不一定有抽象方法）

③==强制要求子类重写父类中的所有抽象方法（除非子类是抽象类）==

④抽象类不能被创建对象，只能用来做“父类”，被子类继承的，体现的是模板思想

⑤抽象类不能被创建对象，但可以有“构造方法”——为从父类继承过来的属性初始化。



#### 8.模版设计模式

解决一些问题时的固定思路（抽象类体现的是模板思想）

例如：新老司机开车功能



### day2



#### 1.final关键字

概念：不可变，用来修饰类、方法、变量

1.修饰类

被final修饰的类不能被继承

`修饰符 final class 类名{ 类中成员 }`

2.修饰方法

被final修饰的方法不能被重写

`修饰符 final 返回值类型 方法名(形参列名){ 方法体  }`

3.修饰变量

被final修饰的变量不能重复赋值,只能赋值一次（注：变量所有字母需大写）

 `final 数据类型 变量名 = 值;`



#### 2.static关键字

静态的意思，用来修饰成员变量、成员方法、代码块

##### 2.1static修饰成员变量

格式： `修饰符 static 数据类型 变量名;`

访问方式：

①对象名.静态成员变量名;

②类名.静态成员变量名;（推荐） 

注意：

1.被static修饰的成员变量会被该类的所有对象共享；

2.如果该类的某个对象修改了静态成员变量的值,那么该类的所有对象使用的都是修改后的值。



##### 2.2==static修饰成员方法==

格式：`修饰符 static 返回值类型 方法名(形参列名){ 方法体}`

访问方式：

①对象名.静态方法名(实参);

②**<font color='red'>类名.静态方法名(实参);</font>**（推荐）

注意：

1.静态方法（也称类方法）中不能出现this关键字（this必须有对象调用，而static修饰的方法通常用类名.方法名()访问，是没有对象的）。

2.静态方法中只能直接访问静态成员变量和静态成员方法，不能直接访问非静态成员变量和非静态成员方法。

4.非静态方法（也称实例方法）中可以直接访问一切成员变量和成员方法。



##### 2.3static修饰代码块（sout有疑惑）

1.格式：`static {  }`

2.位置：类中方法外（类的成员位置）

3.特点：

类加载时自动执行，由于类只加载一次，所以静态代码块也只执行一次（先于构造器、方法执行）。

4.作用：

完成类的初始化（例如：对类变量的初始化赋值）

5.使用场景：

加载驱动，或者放只需要执行一次的代码

![1713601996459](Typoraphoto/1713601996459.png)



#### 3.代码块

执行顺序：静态代码块>构造代码块>局部代码块

##### 3.1静态代码块

static修饰的代码块

具体如上



##### 3.2构造代码块

也称实例代码块

1.格式：`{  }`

2.位置：类中方法外

3.特点：

每次创建对象时，执行实例代码块，并在构造器前执行。

4.作用：

和构造器一样，都是用来完成对象的初始化的（例如：对初始化变量进行初始化赋值）。

5.使用场景：

统计创造了多少个对象。



##### 3.3局部代码块

1.格式：`{  }`

2.位置：方法中

3.执行特点：

调用方法时，执行到了局部代码块的位置才执行（按代码行顺序执行）。

4.使用场景：

节省内存空间，执行完局部代码块即会被先释放掉，而其他非局部代码块的方法变量则需要等到所有方法执行完毕才能释放。==但是！这种作用不大，一般设备内存空间非常大，不需要节省，所以意义不大。==



#### 4.权限修饰符

不同权限的访问能力

```java
				同一个类		同一个包		不同包的父子类			不同包的无关类
public（公共的）   	√				√				√					√
protected（受保护的）	√				√				√					×
默认				   √			   √               ×                   ×
private（私有的）   	  √               ×               ×                   ×
```

开发中的使用：

1.定义类一般使用public

2.定义成员方法一般使用public

3.定义成员变量一般使用private

4.定义构造方法一般使用public



#### 5.接口

1.定义：一种引用类型，主要用来存储数据。

2.成员：**变量**（jdk7及前，public static final）、**抽象方法**（jdk7及前，abstract）、**默认方法**（jdk8，default）、**静态方法**（jdk8，static）、**私有方法**（jdk9，private）。

3.用interface定义接口，会生成class文件。

4.接口无构造方法，也不能创建对象，一般都是供类实现的（implements），类似继承。

5.实现接口的类叫做接口类，实现类如果是普通类必须重写接口中的所有抽象方法，否则实现类只能是一个抽象类。



#### 6.实现接口关系

单实现、多实现、先继承后实现（例：public class 实现类名 extends 父类名 implements 接口名1，接口名2，...{ }）



#### 7.接口中成员访问特点

1.接口中常量：主要供接口名访问，也可以被实现类继承（例：`IA.NUM`或者`Imp.NUM`）

2.接口中抽象方法：供实现类重写（例：`Imp imp=new Imp();  imp.method1();`）

3.接口中默认方法：可以供实现类对象直接调用，或者在实现类中重写（例：`Imp imp=new Imp();  imp.method1();`）

4.接口中静态方法：只供接口名直接访问，不可以被实现类继承（例：` IA.method3();`）（同时也不能被子接口继承）

5.接口中私有方法：只能在接口内部方法中调用，不能被实现类继承



#### 8.接口多实现时的几种冲突情况

1.公有静态常量：多个接口中的同名常量不能被实现类继承，会编译报错。

2.公有抽象方法：必须重写一次抽象方法

3.公有默认方法：必须重写一次默认方法

4.公有静态方法：没有冲突，因为静态方法不会被实现类继承

5.私有方法：没有冲突，因为私有方法不会被实现类继承



#### 9.接口和接口之间的关系

单继承、多继承（public interface C extends A,B{ }）、多层继承（B extends A;  C extends B）



#### 10.接口继承接口的冲突情况

1.公有静态常量：多个接口中同名的常量不会被子接口继承，不同名的会被继承

2.公有抽象方法：多个父接口中有相同的抽象方法，子接口只会继承一个抽象方法（所以子接口或子接口实现类必须重写一次）

3.公有默认方法：多个父接口中有相同的默认方法，子接口必须重写默认方法（default）

4.公有静态方法/私有方法：无冲突，因为不会被子接口继承



#### 11.继承的同时又实现存在的冲突情况

1.父类和接口的公有静态常量：实现类不会继承有冲突的常量，编译报错

2.父类和接口的公有抽象方法：实现类必须重写一次有冲突的抽象方法

3.父类和接口的公有默认方法：权限修饰符相同时，优先访问父类的；~不同时，需要实现类重写一次有冲突的默认方法

4.父类和接口的公有静态方法：不存在冲突，使用的是父类的静态方法

5.父类和接口的私有方法：不存在冲突，因为既不能继承也不能实现



#### 12.接口与抽象类使用场景

1.接口适合定义扩展功能。

2.抽象类适合定义父类下所有子类共有的功能。



### day3

#### 1.多态

概念：对于不同的对象，同一种行为会有不同的表现形式。

例：

```Java
Animal anl=new Dog();
anl.eat();//吃骨头
anl=new Cat();
anl.eat();//吃鱼

//anl的重复赋值相当于
int num=10;
num=20;
```



#### 2.实现多态的前提条件

1.继承或实现

2.父类引用指向子类对象。例：`Animal anl=new Dog();`

3.子类方法的重写（否则这个多态是没有意义的）



#### 3.多态时访问成员特点

|                  | 编译看       | 运行看           |
| ---------------- | ------------ | ---------------- |
| 1.成员变量       | 左边（父类） | 左边（父类）     |
| 2.静态成员方法   | 左边（父类） | 左边（父类）     |
| 3.非静态成员方法 | 左边（父类） | ==右边（子类）== |

非静态成员方法：必须子类中有的成员在父类中也存在时才能运行成功



#### 4.多态的应用场景

##### 4.1变量多态

父类的引用指向子类对象

即：父类类型的变量可以接收该父类类型的对象以及父类类型的所有的子类对象。

例：

```
Animal anl=new Dog();
anl.eat();//吃骨头
anl=new Cat();
anl.eat();//吃鱼
```



##### 4.2形参多态==（常用）==

格式：

```java 
修饰符  返回值  方法名(父类名  变量名){
	变量名.方法名();//该方法与main方法同级
  }
```

参数的类型是父类类型，那么就可以接收该父类类型的对象以及该父类类型的所有子类对象。



##### 4.3返回值多态

格式：

```java 
修饰符  父类名  方法名(参数){
	return 子类对象;//该方法与main方法同级
}
```

返回值类型是父类类型，那么就可以返回该父类类型的对象以及该父类类型的所有子类对象。



#### 5.多态的好处和弊端

1.好处：

可以将方法的参数定义为父类引用，使程序编写简单，提高程序的灵活性、扩展性、复用性。（例，如上形参多态，避免方法的重载，避免多个子类对象写多个方法名相同的功能方法）

2.弊端：

因为所有的方法、变量都是编译看左边父类，所以无法访问子类独有的方法和变量，硬要访问会编译报错（可看多态时访问非静态成员方法特点）。



#### 6.引用类型转换

##### 1.原因：

解决多态不能访问子类独有成员的弊端

##### 2.格式：

向上转型: `父类类型 变量名 = new 子类名(实参);`

向下转型:  `子类类型 变量名 = (子类类型) 父类类型的变量;`

注意：

1.向下转型需先有向上转型（即多态标准写法）

2.向下转换时，父类类型的变量指向的对象一定是左边子类类型的对象

错误示范：

```
Animal anl2=new Cat();
Dog dog2=(Dog) anl2;//运行报转换异常，因为anl2指向的对象是cat而非dog
```



**什么是引用类型**

在Java中，引用类型（Reference Type）是指那些不是基本数据类型（Primitive Data Types）的类型，如类（Class）、接口（Interface）、数组（Array）等。这些类型用于存储指向内存中对象的引用，而不是直接存储对象本身。

Java中什么是引用类型 →点击查看智谱清言智能体「AI搜索」的回答https://chatglm.cn/share/FWCgq

引用类型与基本数据类型的主要区别在于：

- 基本数据类型直接存储值，而引用类型存储的是值的内存地址。
- 基本数据类型的值是直接存储在栈内存中的，而引用类型的对象是存储在堆内存中的。
- 基本数据类型的值是不可变的，而引用类型的对象可以被修改。



#### 7.向下转型判断（instanceof避免转型异常）

instanceof实例化，判断变量是否指向数据类型。如果没有这个判断会报错并终止后续进程。

格式：`变量名 instanceof 数据类型`

例：

```Java
Animal anl1=new Dog();
if (anl1 instanceof Dog){
            Dog dog = (Dog) anl1;
            System.out.println(dog.num);
            dog.lookHome();
        }
```

执行流程:       

```
如果变量指向的对象是属于后面的数据类型,那就返回true
如果变量指向的对象不属于后面的数据类型,那就返回false
```



#### 8.内部类

概念：将一个类定义在另一个类的里面，里面的那个类叫做内部类,外面的那个类就叫做外部类。

特点: 内部类是一个独立的类，在编译后，有自己独立的class文件。



#### 9.成员内部类

1.概念：定义在类的成员位置(类中方法外)的类就叫做成员内部类。

格式：

```Java
class 外部类名{
	class 内部类名{
	
	}
}
```

2.访问特点：

成员内部类中的成员变量和成员方法在其他类中访问时，需要创建成员内部类对象

格式：`外部类名.内部类名 对象名=new 外部类名().new 内部类名();`

3.注意：

- 在成员内部类中,可以直接访问外部类的一切成员,包括外部类的私有成员
- 在外部类中,需要直接访问内部类的成员,需要创建内部类对象来访问

4.局部变量示例：

```Java
class Body {
    int num = 10;
    public class Heart{
        // 成员变量
        int num = 20;
        // 成员方法
        public void show(){
            int num = 30;
            System.out.println("局部变量num:"+num);// 30
            System.out.println("内部类的成员变量num:"+this.num);// 20
            System.out.println("外部类的成员变量num:"+Body.this.num);// 10
        }
    }
}
```



#### 10.匿名内部类

1.本质：是一个继承了父类的匿名子类的对象（一个类的子类对象）。

2.格式：

```Java
new 类名(){
    必须重写所有抽象方法
};

new 接口名(){
    必须重写所有抽象方法
};

示例：
public static void main(String[] args){
Animal anl1 = new Animal() {
            @Override
            public void eat() {
                System.out.println("匿名内部类的eat...");
            }
        };
        anl1.eat();
        }
```

3.作用：用来简化代码--不用创建子类，直接得到子类对象。

4.使用场景：

- 如果想得到一个抽象类的子类对象,那么就可以直接给该类的匿名内部类
- 如果想得到一个接口的实现类对象,那么就可以直接给该接口的匿名内部类



#### 11.引用类型作为方法参数和返回值传递/返回的是地址值

1.参数的类型为接口类型，调用的时候只能传入该接口的实现类对象（因为接口是抽象类，抽象类没有对象，所以不能传入该接口的对象，即父类）。

2.参数类型为类类型，调用的时候可以传入该类的对象或者其子类对象（多态）。

3.返回值类型为接口类型，方法体只能返回该接口的实现类对象（因为接口是抽象类，抽象类没有对象，所以不能传入该接口的对象，即父类）。

4.返回值类型为类类型，方法体可以返回该类的对象或者其子类的对象（多态）。

==注意：==如果类类型为抽象类，那么传递/返回的只能是其子类对象。

示例：

```java
public class Animal {
    String name;
    public Animal() {
    }
    public Animal(String name) {
        this.name = name;
    }
    public void eat(){
        System.out.println("吃东西");
    }
}
public class Test {
    public static void main(String[] args) {
        Animal anld = new Animal("小狗汪汪");
        System.out.println("anld.name = " + anld.name);
        System.out.println("method1(anld).name = " + method1(anld).name);
        /*如果method1方法不加static，就得通过创建对象来调用方法了，如下
        //System.out.println("new Test().method1(anld).name = " + new Test().method1(anld).name);*/
    }
    //需要注意方法要加static
    public static Animal method1(Animal anl){
        anl.name="小猫咪真乖";
        return anl;
    }
}
```

为什么Java类中没加static的方法不能在方法中调用... →点击查看智谱清言的回答https://chatglm.cn/share/FWNgE

简略原因：

1.查看static修饰方法知识点

2.没有关键字static修饰的就是实例方法，实例方法需要创建对象后使用。static修饰的是静态方法，可直接用类名.方法名调用，如果在同一类，那直接方法名调用即可。



#### 12.引用类型作为成员变量

可看个人代码库的代码

```Java
abstract class Pet{}

interface FaShu{}

class Person{
    int age;// 基本类型作为成员变量
    String name; // 普通类作为成员变量
    Pet pet;// 抽象类作为成员变量
    FaShu fs;// 接口作为成员变量
}

public class Test {
    public static void main(String[] args) {
        // 创建Person对象
        Person p = new Person();
        // 给p对象的属性赋值
        p.age = 18;
        p.name = "张三";
        p.pet = new Pet() {};// 成员变量类型为抽象类,那么就赋该抽象类的子类对象
        p.fs = new FaShu() {};// 成员变量类型为接口,那么就赋该接口的实现类对象
    }
}
```



#### 13.包装类

概念：为了更好的维护基本类型数据，java为基本类型创建了对应的引用类型，这些类称为包装类。

分类:

```java
| 基本类型 | 对应的包装类（位于java.lang包中） |
|   byte   |               Byte                |
|  short   |               Short               |
|   int    |               Integer             |
|   long   |               Long                |
|  float   |               Float               |
|  double  |              Double               |
|   char   |             Character             |
| boolean  |              Boolean              |

```



#### 14.包装类装箱和拆箱

1.装箱: 把基本类型转换为对应的包装类类型---->包装类的构造方法\valueOf静态方法可以实现

2.拆箱:  把包装类类型转换为对应的基本类型---->包装类的 `xx类型Value()` 非静态方法实现

```Java
// Integer的构造方法（已过时）
        Integer i1 = new Integer(10);// 表示整数10

// Integer的静态方法
        Integer i2 = Integer.valueOf(10);// 表示整数10

 // 拆箱: 包装类型类型---->基本类型
        int num1 = i1.intValue();// 10
```



3.自动装箱和自动拆箱

自动装箱: 基本类型自动转换为对应的包装类类型---->直接把基本类型的值赋值给对应的包装类类型变量

自动拆箱:  包装类类型自动转换为对应的基本类型---->直接把包装类的对象赋值给对应的基本类型的变量

```java
public class Test {
    public static void main(String[] args) {
        // - 自动装箱: 基本类型自动转换为对应的包装类类型---->直接把基本类型的值赋值给对应的包装类类型变量
        Integer i1 = 10;
        Double d = 3.14;

        // - 自动拆箱:  包装类类型自动转换为对应的基本类型---->直接把包装类的对象赋值给对应的基本类型的变量
        int num = i1;
        double numD = d;
        System.out.println(num + 10);//20
    }
}
```



#### 15.基本类型和字符串之间的转换

##### 15.1基本类型转字符串方式

1.基本类型的数据+空的字符串("")

2.==字符串==（String类）的静态方法`public static String valueOf(基本类型的值);`

3.toString()方法



##### 15.2字符串转基本类型方式

1.通过包装类的静态方法`public static 基本数据类型 valueOf(String s)`得到包装类对象，然后包装类对象自动拆箱为基本类型（除了Character包装类之外，其他的包装类都有这个方法。只能使用`String对象.charAt(0)`）。

2.通过包装类的静态方法`public static 基本数据类型 parseXXX类型(String s)`得到对应的基本类型（除了Character包装类之外，其他的包装类都有这个方法）。



```jAVA
//基本类型转字符串类型，valueOf()方法，toString()方法,构造方法
        //Integer i1 = new Integer(12);//在jdk中已过时，不用
        /*//装箱: 把基本类型转换为对应的包装类类型
        Integer i2 = Integer.valueOf(11);
        System.out.println("i2 = " + i2);
        System.out.println("Integer.valueOf(23) = " + Integer.valueOf(23));*/
        String si1 = String.valueOf(13);
        System.out.println("si1 = " + si1);
        System.out.println("String.valueOf(15) = " + String.valueOf(15));

        String s1 = Double.toString(23.22);
        System.out.println("s1 = " + s1);
        System.out.println("Double.toString(12.11) = " + Double.toString(12.11));

		int num1 = 100;
        String str1 = num1 + "";

        //字符串类型转基本数据类型,valueOf(String s)方法，paseXX类型(String s)方法
        Integer i5 = Integer.valueOf("135");
        //自动拆箱
        int num=i5;
        System.out.println("i5 = " + i5);

        Float i6=Float.parseFloat("1.22");
        float f=i6;
        System.out.println("f = " + f);
```



##### 15.3String类中都有ToString方法

```java 
Integer i2 = Integer.valueOf(11);
System.out.println("i2 = " + i2);//11
```

Integer a=Integer.v... →点击查看智谱清言的回答https://chatglm.cn/share/FWN5o

`toString()`方法的作用是将一个对象转换成字符串形式，以便于打印或者与其他字符串操作。



##### 15.4哪些类有重写过的toString方法

在Java中，`Object` 类是所有类的根，它定义了 `toString()` 方法，用于返回对象的字符串表示形式。这个方法通常包含对象所属的类名和对象的哈希码值。许多类都重写了 `Object` 类的 `toString()` 方法，以提供更有意义的字符串表示形式，这通常包括对象的关键属性。
以下是一些常见类，它们重写了 `toString()` 方法：
1. **`String`**：
   - `String` 类重写了 `Object` 类的 `toString()` 方法，返回字符串对象的字符序列。
2. **`Integer`、`Double`、`Float`、`Long` 等包装类**：
   - 这些包装类重写了 `toString()` 方法，以返回它们所表示的数值的字符串形式。
3. **`Date` 和 `Calendar` 类**：
   - 这些类重写了 `toString()` 方法，以返回日期和时间的字符串表示形式。
4. **`File` 类**：
   - `File` 类重写了 `toString()` 方法，以返回文件或目录的路径名。
5. **`ArrayList`、`HashSet`、`HashMap` 等集合类**：
   - 这些集合类重写了 `toString()` 方法，以返回集合中元素的字符串表示形式。
6. **自定义类**：
   - 开发者经常会在自定义类中重写 `toString()` 方法，以提供对象的属性和状态的描述性字符串表示形式。
这些类的 `toString()` 方法通常包括一些属性或状态信息，以便于调试和日志记录。重写 `toString()` 方法是Java编程中非常常见的一个做法，特别是在需要输出对象信息时。



### day4

#### 1.Object类

##### 1.1Object类概念

1.java.lang.Object类是java语言的根类，所有java类的父类。

2.在java中所有的类都是直接或者间接继承Object类。



##### 1.2toString方法重写（返回该对象的字符串）

快捷键：alt+insert，选toString，或者直接输toString选择重写

`public String toString() 返回该对象的字符串表示。`
            1.因为java中所有的类都会继承Object类,所以所有的类都拥有toString方法
            2.Object类中的toString方法返回的字符串格式默认为: 类的全名+@+地址值
            3.如果不想使用toString方法的默认返回值,那么就得重写toString方法
            4.直接打印对象名,其实打印的是该对象调用toString方法返回的字符串内容



##### 1.3equals方法重写（判断两个对象是否相等）

快捷键：alt+insert，选equals() and hashCode()，或者直接输equals选择重写

`public boolean equals(Object obj)：判断2个对象是否相等。`

Object类的equals方法默认比较的是地址值，如果希望比较的不是地址值,而是所有的属性值。



##### 1.4==Objects==工具类

==注意是有s的Objects类哦，包名有util注意别选错，java.util.Objects==

在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashCode、返回对象的字符串表示形式、比较两个对象。

在比较两个对象的时候，Object的equals方法容易抛出空指针异常（见1.3equals方法重写），而Objects类中的equals方法就优化了这个问题。

`public static boolean equals(Object a, Object b)`:判断两个对象是否相等。

```java
class Person{
    String name;
    int age;
    public Person(String name,int age){
        this.name=name;
        this.age=age;
    }
    public Person(){}
/*@Override
    //初步写法，缺点速度慢，当参数o为null时会报空指针异常
    public boolean equals(Object o){
        Person p=(Person) o;
        return this.name.equals(p.name)&&this.age==p.age;
    }*/
@Override
    public boolean equals(Object o){
        //如果两个对象地址值相同，直接返回true结束方法
        if (this==o) return true;
        //如果参数为null，或者两个对象的类不同，直接返回false结束方法
        if (o==null||getClass()!=o.getClass()) return false;
        //执行到这里，说明地址值相同，类相同，不为null。于是比较所有属性是否相同
        //多态的向下转型，访问子类的独有成员
        Person p=(Person) o;
        //注意是Objects工具类的equals方法
        return age==p.age&& Objects.equals(name,p.name);
    }}
```



#### 2.Date类

1.概述

java.util.Date类表示日期,内部精确到毫秒.表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。

2.Date类中的构造方法

```
public Date();当前系统时间对应的日期对象
public Date(long mills);距离标准基准时间 指定偏移毫秒数 对应的日期对象
```

3.Date类中的常用方法

```
public long getTime();获取当前日期对象距离标准基准时间的毫秒值
public void setTime(long time);把毫秒值给标准时间
public boolean after(Date when) 判断此日期是否在指定日期之后
public boolean before(Date when) 判断此日期是否在指定日期之前
```



#### 3.DateFormat类

##### 1.DateFormat类概述

 java.text.DateFormat 该类可以使得在Date对象与String对象之间进行来回转换。

注意: DateFormat是一个抽象类,无法创建对象,应该使用其子类来实现Date和String之间的转换。

##### 2.SimpleDateFormat类概述

 java.text.SimpleDateFormat 该类继承DateFormat类,所以该类也可以使得在Date对象与String对象之间进行来回转换。

##### 3.构造方法

```Java
public SimpleDateFormat(String pattern)：传入日期指定格式,创建SimpleDateFormat对象

1.参数: 指定的日期格式
2.日期格式的组成元素: 
y: 年
M: 月
d: 日
H: 时
m: 分钟
s: 秒
3.常见的日期格式:
yyyy-MM-dd HH:mm:ss
yyyy年MM月dd日 HH:mm:ss
```

##### 4.常用方法

```Java
public String format(Date date)：将Date对象格式化为字符串。
public Date parse(String source)：将字符串解析为Date对象。

示例：
 public static void main(String[] args) throws ParseException {
        // 创建日期格式化对象,指定日期格式为:yyyy-MM-dd HH:mm:ss
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

        // - public String format(Date date)：将Date对象格式化为字符串。
        // 创建当前系统时间的日期对象
        Date nowDate = new Date();
        // Date-->String
        String strDate = sdf.format(nowDate);
        System.out.println("strDate:" + strDate);// 2021-03-20 11:23:59

        // - public Date parse(String source)：将字符串解析为Date对象。
        // 创建一个表示出生日期的字符串对象
        String birthday = "1996-10-01 08:08:08";
        // String-->Date
        Date birthdayDate = sdf.parse(birthday);
        System.out.println("birthdayDate:" + birthdayDate);// Tue Oct 01 08:08:08 CST 1996
```

##### 5.注意：

日期格式化对象中指定的日期要和解析的字符串日期格式一致,否则会报解析异常ParseException解析异常。



#### 4.Calendar类

##### 1.Calendar概述

`java.util.Calendar`类表示一个“日历类”，可以进行日期运算。

特点：

1.Calendar类是一个抽象类，不能创建对象,所以只能使用其子类

2.子类:  GregorianCalendar。



##### 2.获取日历对象

```Java
方式一：通过 GregorianCalendar 子类的构造方法（不建议）

方式二：通过Calendar类的静态方法getInstance()
public static Calendar getInstance();
```

注意：

- 日历对象中的月份是0-11, 0表示1月,依次类推, 11表示12月
- 日历对象中的星期是1-7,  1表示星期天,依次类推,7表示星期六



3.Calendar类的常用方法

```Java
public int get(int field)  获取某个字段的值。
public void set(int field,int value)  设置某个字段的值
public void add(int field,int amount)  为某个字段增加/减少指定的值
public void setTime(Date date) 修改当前日历对象表示的时间（将日期对象转日历对象）。
public boolean after(Object when)判断当前日历对象是否在指定的日历对象之后
public boolean before(Object when) 判断当前日历对象是否在指定的日历对象之前
public Date getTime() 日历对象转日期对象

```



#### 5.Math类

1.概述： java.lang.Math(类): Math包含执行基本数字运算的方法的工具类。

2.特点：

Math类构造方法被私有修饰，不能创建对象。

操作的时候,都是通过Math类名直接调用该类的静态方法即可。

3.常用方法：

```Java
public static int abs(int a)                   获取参数a的绝对值
public static double ceil(double a)            向上取整 (得到大于参数的最小整数)
public static double floor(double a)           向下取整(得到小于参数的最大整数)
public static double pow(double a, double b)   获取a的b次幂
public static long round(double a)             四舍五入取整
public static int max(int a, int b)            返回两个 int 值中较大的一个
public static int min(int a, int b)            返回两个 int 值中较小的一个
```



#### 6.System类

1.概述：java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。

2.特点：

System类构造方法被私有修饰，不能创建对象。

直接通过System类名调用该类的静态方法。

3.常用方法

```Java
public static void exit(int status)    终止当前运行的Java虚拟机，非零表示异常终止
public static long currentTimeMillis() 返回当前时间距离标准基准时间的毫秒值;
```

4.案例：在控制台输出1-10000，计算这段代码执行了多少毫秒



#### 7.BigInteger类

1.概述：java.math.BigInteger  表示一个超大的整数

2.构造方法

```Java
public BigInteger(String value); 根据字符串内容创建一个超大的整数对象
注意: 字符串参数一定要传整数的字符串
```

3.成员方法

```Java
public BigInteger add(BigInteger value)  		加法运算
public BigInteger subtract(BigInteger value)  		减法运算 
public BigInteger multiply(BigInteger value)  		乘法运算
public BigInteger divide(BigInteger value)  		除法运算
```



#### 8.BIgDecimal类

1.概述：java.math.BigDecimal类,表示一个超大的小数,并且可以解决小数运算的精度问题

2.构造方法

```Java
BigDecimal(double val)  将double类型的数据封装为BigDecimal对象（不推荐使用,因为使用这个依然还是有精度问题，即0.01+0.09=0.09999999，无法等于0.1）
BigDecimal(String val)  将 BigDecimal 的字符串表示形式转换为 BigDecimal
```

3.常用方法

```Java
public BigDecimal add(BigDecimal value)  		加法运算  
public BigDecimal subtract(BigDecimal value)  		减法运算  
public BigDecimal multiply(BigDecimal value)  		乘法运算  
public BigDecimal divide(BigDecimal value)  		除法运算
```

==注意==:如果使用上面的除法运算的方法,遇到除不尽的就会报数学运算异常,得使用下面重载的方法

```Java
public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) 除法运算

参数1: 除数
参数2: 精确的位数
参数3: 取舍的模式  RoundingMode.HALF_UP: 四舍五入
```



#### 9.Arrays类

1.概述：该类包含用于操作数组的各种静态方法（如排序和搜索）。

2.常用方法

```java
public static void sort(int[] a)：按照数字顺序排列指定的数组 升序 
public static String toString(int[] a)：返回指定数组的内容的字符串表示形式
```



#### 10.idea快捷键ctrl+n  搜索