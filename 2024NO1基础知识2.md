### day1

#### 1.类和对象

##### 1.定义一个类

格式

```
修饰符 class 类名{
    //类中的五大成分。
    1.成员变量（属性）
    2.成员方法 (行为。无static，自定义方法+get、set方法) 
    3.构造器 （初始化类的对象数据的。构造方法）
    4.内部类（后续补充）
    5.代码块
}
```



#### 2.继承（有内存图）

格式：

```
修饰符 class 子类名 extends 父类名{

}
```



![1713602081050](Typoraphoto/1713602081050.png)



#### 3.一个文件可以定义多个类

注意：

1.该文件中只能有一个public修饰的类
2.public修饰的类的类名必须和文件名一致
3.开发中,一般是一个类对应一个文件



#### 4.继承后成员访问规则

##### 1.构造方法

子类构造方法用super调用（空参构造可直接访问）

##### 2.私有成员

①私有成员变量

set、get方法

②私有成员方法

父类公共方法间接访问

##### 3.非私有成员

直接访问



#### 5.方法重写

子类中出现与父类一模一样的方法（返回值类型，方法名和参数列表都相同）。

注意事项：

1.父子类关系

2.概念

3.子类方法重写父类方法，必须权限大于父类权限

public >  protected  > (默认) > private

4.加上@Override注解，检验是否重写成功，重写注解校验（提高代码的可读性）。



方法重载：

在同一个类中，出现多个同名的方法，仅参数列表不同，与其他无关。



#### 6.关键字this、super

##### 1.this

访问本类的成员属性、成员方法、构造方法（this（实参））

注意：

1.this调用本类的构造方法必须放在构造方法的第一行
2.两个本类的构造方法不能使用this相互调用

##### 2.super

访问父类的成员属性（super.父类成员变量）、成员方法（super.成员方法名（实参））、构造方法（super（实参））

注意：

1.super访问父类的构造方法一定要放在子类构造方法的第一行
2.子类构造方法默认会调用父类的空参构造方法
3.在子类构造方法中调用父类的构造方法,其实就是为了初始化从父类继承过来的属性



#### 7.抽象类

使用abstract关键字修饰的类就是抽象类，没有方法体（直接；分号收尾）。

格式：修饰符  abstract  class  类名{  }

成员：

1.成员变量

2.成员方法

3.构造方法

4.抽象方法

①格式：修饰符  abstract  返回值类型  方法名(形参列表)；

②不是必须有，但有抽象方法的类一定是抽象类（不过抽象类中不一定有抽象方法）

③==强制要求子类重写父类中的所有抽象方法（除非子类是抽象类）==

④抽象类不能被创建对象，只能用来做“父类”，被子类继承的，体现的是模板思想

⑤抽象类不能被创建对象，但可以有“构造方法”——为从父类继承过来的属性初始化。



#### 8.模版设计模式

解决一些问题时的固定思路（抽象类体现的是模板思想）

例如：新老司机开车功能



### day2



#### 1.final关键字

概念：不可变，用来修饰类、方法、变量

1.修饰类

被final修饰的类不能被继承

`修饰符 final class 类名{ 类中成员 }`

2.修饰方法

被final修饰的方法不能被重写

`修饰符 final 返回值类型 方法名(形参列名){ 方法体  }`

3.修饰变量

被final修饰的变量不能重复赋值,只能赋值一次（注：变量所有字母需大写）

 `final 数据类型 变量名 = 值;`



#### 2.static关键字

静态的意思，用来修饰成员变量、成员方法、代码块

##### 2.1static修饰成员变量

格式： `修饰符 static 数据类型 变量名;`

访问方式：

①对象名.静态成员变量名;

②类名.静态成员变量名;（推荐） 

注意：

1.被static修饰的成员变量会被该类的所有对象共享；

2.如果该类的某个对象修改了静态成员变量的值,那么该类的所有对象使用的都是修改后的值。



##### 2.2static修饰成员方法

格式：`修饰符 static 返回值类型 方法名(形参列名){ 方法体}`

访问方式：

①对象名.静态方法名(实参);

②类名.静态方法名(实参);（推荐）

注意：

1.静态方法（也称类方法）中不能出现this关键字（this必须有对象调用，而static修饰的方法通常用类名.方法名()访问，是没有对象的）。

2.静态方法中只能直接访问静态成员变量和静态成员方法，不能直接访问非静态成员变量和非静态成员方法。

4.非静态方法（也称实例方法）中可以直接访问一切成员变量和成员方法。



##### 2.3static修饰代码块（有疑惑）

1.格式：`static {  }`

2.位置：类中方法外（类的成员位置）

3.特点：

类加载时自动执行，由于类只加载一次，所以静态代码块也只执行一次（先于构造器、方法执行）。

4.作用：

完成类的初始化（例如：对类变量的初始化赋值）

5.使用场景：

加载驱动，或者放只需要执行一次的代码

![1713601996459](Typoraphoto/1713601996459.png)



#### 3.代码块

执行顺序：静态代码块>构造代码块>局部代码块

##### 3.1静态代码块

static修饰的代码块

具体如上



##### 3.2构造代码块

也称实例代码块

1.格式：`{  }`

2.位置：类中方法外

3.特点：

每次创建对象时，执行实例代码块，并在构造器前执行。

4.作用：

和构造器一样，都是用来完成对象的初始化的（例如：对初始化变量进行初始化赋值）。

5.使用场景：

统计创造了多少个对象。



##### 3.3局部代码块

1.格式：`{  }`

2.位置：方法中

3.执行特点：

调用方法时，执行到了局部代码块的位置才执行（按代码行顺序执行）。

4.使用场景：

节省内存空间，执行完局部代码块即会被先释放掉，而其他非局部代码块的方法变量则需要等到所有方法执行完毕才能释放。==但是！这种作用不大，一般设备内存空间非常大，不需要节省，所以意义不大。==



#### 4.权限修饰符

不同权限的访问能力

```java
				同一个类		同一个包		不同包的父子类			不同包的无关类
public（公共的）   	√				√				√					√
protected（受保护的）	√				√				√					×
默认				   √			   √               ×                   ×
private（私有的）   	  √               ×               ×                   ×
```

开发中的使用：

1.定义类一般使用public

2.定义成员方法一般使用public

3.定义成员变量一般使用private

4.定义构造方法一般使用public



#### 5.接口

1.定义：一种引用类型，主要用来存储数据。

2.成员：**变量**（jdk7及前，public static final）、**抽象方法**（jdk7及前，abstract）、**默认方法**（jdk8，default）、**静态方法**（jdk8，static）、**私有方法**（jdk9，private）。

3.用interface定义接口，会生成class文件。

4.接口无构造方法，也不能创建对象，一般都是供类实现的（implements），类似继承。

5.实现接口的类叫做接口类，实现类如果是普通类必须重写接口中的所有抽象方法，否则实现类只能是一个抽象类。



#### 6.实现接口关系

单实现、多实现、先继承后实现（例：public class 实现类名 extends 父类名 implements 接口名1，接口名2，...{ }）



#### 7.接口中成员访问特点

1.接口中常量：主要供接口名访问，也可以被实现类继承（例：`IA.NUM`或者`Imp.NUM`）

2.接口中抽象方法：供实现类重写（例：`Imp imp=new Imp();  imp.method1();`）

3.接口中默认方法：可以供实现类对象直接调用，或者在实现类中重写（例：`Imp imp=new Imp();  imp.method1();`）

4.接口中静态方法：只供接口名直接访问，不可以被实现类继承

5.接口中私有方法：只能在接口内部方法中调用，不能被实现类继承



#### 8.接口多实现时的几种冲突情况

1.公有静态常量：多个接口中的同名常量不能被实现类继承，会编译报错。

2.公有抽象方法：必须重写一次抽象方法

3.公有默认方法：必须重写一次默认方法

4.公有静态方法：没有冲突，因为静态方法不会被实现类继承

5.私有方法：没有冲突，因为私有方法不会被实现类继承



#### 9.接口和接口之间的关系

单继承、多继承（public interface C extends A,B{ }）、多层继承（B extends A;  C extends B）



#### 10.接口继承接口的冲突情况





#### 11.继承的同时又实现存在的冲突情况





#### 12.接口与抽象类使用场景

1.接口适合定义扩展功能。

2.抽象类适合定义父类下所有子类共有的功能。



### day3

1.



