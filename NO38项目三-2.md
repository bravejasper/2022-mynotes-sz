#### 1.通用controller抽取

```
通用controller抽取
  * 定义5个接口：CRUD+分页
  * 定义ICoreController接口,组合了5个接口
  * 定义AbstractCoreController对ICoreController实现
     通过bean对象获取查询条件 getWrapper()
        获取bean对象类型
        获取类下的所有属性
        遍历属性
           如果属性是主键或serialVersionUID则不处理
           BeanUtils通过属性名获取属性描述器, BeanUtils缓存反射过的类。
           通过属性描述器获取getter方法
           反射调用getter方法，获取属性的值
           获取属性上的注解(@TableFeild),得到它的value，就相当于得到列名
           有了列名与属性值，就可以构建QueryWrapper中的条件
  * 需要CRUD+分页，它的controller 继承AbstractCoreController
    子类要实现有参构造方法,把子类的service传给父类
   
```

##### 1.1通过controller抽取的方法实现敏感词的增删改查操作步骤：

```
通过controller抽取的方法实现敏感词的增删改查：
1.创建核心接口多个和核心接口的实现类一个（该类为抽象类），AbstractCoreController
2.创建实体类pojo，AdSensitive
3.创建mapper映射，指定实体类，AdSensitiveMapper
4.创建service接口，AdSensitiveService
5.创建接口实现类AdSensitiveServiceImpl
6.创建AdSensitiveController
```

通用controller抽取

##### 1.2反射缓存

![1668241489752](D:\学习资料\个人笔记\Typoraphoto\1668241489752.png)

##### 1.3？？？子类要实现有参构造方法,把子类的service传给父类，子传父为什么

#### 2.指定泛型类型，就知道操作的是哪个实体



#### 3..分页查询敏感词

```
通过controller抽取的方法实现敏感词的增删改查：
1.创建核心接口多个和核心接口的实现类一个（该类为抽象类），AbstractCoreController
2.创建实体类pojo，AdSensitive
3.创建mapper映射，指定实体类，AdSensitiveMapper
4.创建service接口，AdSensitiveService
5.创建接口实现类AdSensitiveServiceImpl
6.创建AdSensitiveController
```

![1668254878812](Typoraphoto/1668254878812.png)



![1668254836778](Typoraphoto/1668254836778.png)



#### 4.属性描述器PropertyDescriptor

```
判断方法是看有没有提供get、set方法。属性描述器不需要拼接方法名（"get"+feild.getName().substring(0,1).toUpperString() + field.getName.substring(1);）
```



#### 5.slf4j log4j logback关系详解和相关用法

1.slf4j是java的一个日志门面，实现了日志框架一些通用的api，log4j和logback是具体的日志框架。

2.他们可以单独的使用，也可以绑定slf4j一起使用。

- 单独使用。分别调用框架自己的方法来输出日志信息。
- 绑定slf4j一起使用。调用slf4j的api来输入日志信息，具体使用与底层日志框架无关（需要底层框架的配置文件）

3.log4j 、logback区别：

```
log4j是apache实现的一个开源日志组件。（Wrapped implementations）
logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架。是slf4j的原生实现。（Native implementations）
```

4.使用slf4j绑定日志系统的优势

- 软件工程的角度。抽象，解耦，便于维护。可以参考一下上面的例子。
- 语法设计角度。slf4j有{}占位符，而log4j需要用“+”来连接字符串，既不利于阅读，同时消耗了内存（heap memory）。
- 详细的描述可以参考：[slf4j log4j logback关系详解和相关用法 - Fururur - 博客园 (cnblogs.com)](https://www.cnblogs.com/Sinte-Beuve/p/5758971.html)



#### 6.knife4j

knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍。

使用步骤：

```
方法一（day1）：
1.引入依赖
2.创建Swagger配置文件
```

```
方法二（day2）：
1.工程复制到itheima-leadnews-core父工程下
2.itheima-leadnews-core的pom文件添加module
3.itheima-leadnews-service工程的pom文件中添加 knife4j起步依赖
4.admin工程的yml文件添加配置信息
最后把service-admin里的config-swagger文件删除
```



#### 7.验证生成token

```
生成token
1.新建main方法，
2.设置token内容：ID、签发时间、加密方式、过期时间戳、cla信息载荷
```



```
//验证有效性，解析
        Claims claims = Jwts.parser()
                .setSigningKey(generalKey())
                .parseClaimsJws(token).getBody();
        System.out.println(claims);
        String username = claims.get("username",String.class);
        Integer id = claims.get("id", Integer.class);
        System.out.println("username="+username+",id="+id);
```



#### 8.？？？文档注释

为什么老师的能自动生成，我的不行

![1668323894091](Typoraphoto/1668323894091.png)



#### 9.登录验证功能

##### 9.1实现步骤

```
登录验证功能步骤：
LoginUserVo
LoginController 登录校验 
AdUserService 业务接口 
AdUserServiceImpl 业务实现，详细： 
1.参数非空校验 
2.验证通过，通过用户名查询用户信息 
3.密码校验 
3.1把前端的密码进行 加盐 加密 处理 
3.2把前端的密码与后端数据库密码进行对比 
4.不相同时则报错 
5.生成token 
6.构建用户信息，LoginUserVo 再返回  一个是token，另一个是user用户信息  记得脱敏  
```

##### 9.2登录验证调试

1.准备

1.1前端发送登录请求

![1668334431994](Typoraphoto/1668334431994.png)

1.2控制台点F8进行调试

![1668334497110](Typoraphoto/1668334497110.png)

1.3数据库密码情况

![1668334587960](Typoraphoto/1668334587960.png)

2.F8下一步到3.2数据库密码对比处`if (!encryptedPwd.equals(loginUser.getPassword())){`，可看出与数据库密码不一致

![1668334706008](Typoraphoto/1668334706008.png)

3.复制加密后的密码，粘贴到数据库，记得更新修改后的数据库

![1668334901985](Typoraphoto/1668334901985.png)

4.重新从数据库中查询密码，点击Evaluate Expression评估表达，好像必须选择这一句`loginUser = query().eq("name", name).one()`，选择其他的会修改不成功

![1668335041929](Typoraphoto/1668335041929.png)

5.Evaluate评估

![1668335239387](Typoraphoto/1668335239387.png)

6.此时可看到密码都更正了

![1668335326536](Typoraphoto/1668335326536.png)

7.到`return loginUserVo;`时，点击F9跳出即可

![1668335392394](Typoraphoto/1668335392394.png)

8.此时前端方响应返回数据

![1668335489843](Typoraphoto/1668335489843.png)



#### 10.idea springboot启动配置

![1668410208828](Typoraphoto/1668410208828.png)



#### 11.启动nacos

```
启动nacos
1.最外层的pom.xml添加依赖，注意nacos版本和springboot对应
2.service-admin添加nacos地址配置
3.账号密码均为nacos
4.启动地址：192.168.17.128:8848
```



#### 12.网关校验功能

```
网关校验功能：
创建itheima-leadnews-gateway-admin工程
1.pom.xml引入依赖
2.application.yml、application-dev、application-prod、application-test添加配置 --》跨域处理
   路由配置
3.创建启动类GatewayAdminApplication
 日志配置
```

测试postman：

启动网关和admin工程

![1668478972754](Typoraphoto/1668478972754.png)



#### 13.接口定义规范，抽象类用于通用抽取

#### 14.代码生成器

```
介绍代码生成器
  * 修改配置文件 module, 数据库，application.name
  * 运行CodeGenerator，其它java代码可以删除
  * 把pojo复制到api工程里pojo
  * 把controller service mapper复制到微服务工程
  * 把resource下的mapper目录下的映射文件复制微服务的resource的mapper目录下
```



#### 15.Token令牌

```
Token令牌
  有状态通讯：用户登录后，把登录用户信息保存在服务端,安全可靠。占用内存空间 （金融与保险行业）
  无状态通讯：用户登录后，服务端不存储登录用户信息，登录用户信息存在token里，用户每次请求时必须带上token。优点：不占空间，缺点：相对没那么安全 社交软件
```



#### 16.Jwt: Json Web Token

```
Jwt: Json Web Token, 对token令牌一种实现。实现无状态通讯一种工具
  组成：
    * Header(版本、id, 签名算法HS512)
    * Payload 载荷：自有的属性，自定义属性(map: 存放登录用户信息，不能包含敏感信息)
    * Signature签名：验证token的完整性，是否被修改过。头部中的签名算法对(base64(header)+base64(payload), 密钥) 进行加密，加密后得到 base64(header).base64(payload).signature 
  Jwt使用：
     登录成功: 生成token   
     验证：解析token而不报错，验证通过，即用户已经登录过了
     解析：获取header, Base64解码, 得到算法名称, 使用头中的算法(header+payload, 密钥) 得到加密后的字符串(signature签名), 与token中的签名对比，如果一样说明通过，如果不一样说明被修改了。签名一样，获取载荷的过期时间与当前系统时间进行对比,判断是否超时 
```



#### 17.后管理系统登录功能

```
后管理系统登录功能
 * 需要分析：操作哪张表 ad_user表(name,password,salt,status)
 * 接口：/admin/login/in, 
        提交的参数{name:,password:} 
        请求体 响应的LoginUserVo(common工程vo包下)(token, user)
 * 实现:
前端提交的密码提交到LoginController 中，LoginController 定义一个方法来接收前端提交来的用户名和密码，他是一个json数据，通过map接收，使用的是@requestbody注解，接收后获取参数中的用户名和密码，接着进行参数非空校验，如下
   * LoginController ("/login") ("/in")loginCheck, 接收参数Map<String,String>
   * AdUserServiceImpl
    1.参数校验(非空校验)
    2.通过用户名查询用户信息
    3.用户信息不存在则报错
    4.存在
      4.1 判断用户的状态，如果不为9，联系管理员
      4.2 比较密码：把前端密码加盐加密
      4.3 与数据库的密码比较，如果不一样则报错
    5. 通过登录用户id生成token
    6. 构建LoginUserVo
    7. 登录用户信息脱敏(salt,password,phone设置为null)
    8. 返回vo
  【注意】数据库admin的密码是错的，得先自己手工运行生成密码，更新到数据库
```



#### 18.网关的作用

![1668484388866](Typoraphoto/1668484388866.png)



19.

![1668484663691](Typoraphoto/1668484663691.png)