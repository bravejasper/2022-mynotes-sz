## 一、Java技术体系 

| **技术体系**                              | **说明**                     |
| ----------------------------------------- | ---------------------------- |
| Java SE(Java Standard Edition):标准版     | Java技术的核心和基础         |
| Java EE(Java Enterprise   Edition):企业版 | 企业级应用开发的一套解决方案 |
| Java ME(Java Micro Edition):小型版        | 针对移动设备应用的解决方案   |

## 二、HelloWorld程序介绍

1.代码：

```
public class HelloWorld {
//class定义一个类，后面跟上的HelloWorld是类名称
     public static void main(String[] args) {
     //main方法是程序执行的入口点，也是主方法
         System.out.println(" HelloWorld ");
  }
 }
```

2.程序经历的步骤

编写、编译（javac）、运行（java），其中运行包括加载和执行。

3.命令行窗口常用命令

| 盘符名称：                                         | 切换到某个盘下：D: ， C:                                     |
| -------------------------------------------------- | ------------------------------------------------------------ |
| dir                                                | 查看当前路径下的内容                                         |
| cd 目录<br />cd 目录1\目录2<br /> cd .. <br />cd \ | 进入单级目录: cd itheima<br />进入多级目录: cd  D:\itheima\JavaSE\第一天<br />回退到上一级目录：cd ..<br />回退到盘符根目录：cd \ |
| cls                                                | 清屏                                                         |
| exit                                               | 退出                                                         |

## 三、JDK相关

1.JDK组成：

![img](https://img-blog.csdnimg.cn/8469b330c6aa42e1becc0ef20b0342fa.png)

2.JDK安装后配置Path

较新的JDK安装时会自动配置javac、java路径到Path环境变量中，但是老版本，比如JDK8，是需要自己手动配置的。

第一步，在path里添加jdk的bin目录路径，例如：path  E:\WorkSoftware\Java\jdk-17.0.3.1\bin

第二步，在用户变量（系统变量也可以）里添加    JAVA_HOME  %JAVA_HOME%\bin

注意，第二步选择%JAVA_HOME%\bin而不是bin的路径E:\WorkSoftware\Java\jdk-17.0.3.1\bin，是因为，如果后续JDK版本更新了，那路径中间的版本号信息就会限制系统找到JDK位置，而无法正常运行。

## 四、idea项目结构

project（项目、工程）-->model（模块）-->package（包）-->class（类）

注意（也可在最后运行调试时检查）：

![1657011439983](typora-user-images\1657011439983.png)

1.要检查project里是否有添加SDK版本（编译），以及语言水平是否也是SDK的相应版本（运行）；

2.检查项目编译器输出是否有输出路径，该输出路径在项目的下一级。该目录下包含生产和测试两个子目录，分别用于生产代码和测试源。

## 五、idea快捷操作

1.生成main方法： psvm+回车

2.输出语句：sout

3.复制粘贴行：Ctrl+D

4.自动格式化代码（让代码变整齐）： Ctrl+alt+L

5.自动补齐代码：Ctrl+Alt+Space（空格）

6.选择多行相同列的内容：Alt+鼠标选择 

7.重命名：Shift+F6

## 六、导入导出

### 1.idea设置

Manage IDE Settings--Import Settings

### 2.项目的模块

**注意：**项目的模块中如果有一个包下面的类有错，则其下的所有的Java文件都不能运行

## 七、注释

```
单行注释 格式：//注释信息  Ctrl+/
多行注释 格式：/* 注释信息 */  Ctrl+Shift+/
文档注释 格式：/** 注释信息 */
```

```
//package标记了当前类所在的包
package com.itheima.demo1exegesis;
//类的格式：public class 类名{}
public class HelloWorld {
    //这是main方法，是程序的入口。
    public static void main(String[] args) {
        //这是一个输出语句，小括号中的内容会被输出到控制台
        System.out.println("HelloWorld000");
```

## 八、关键字

具有特殊含义的小写单词，在idea中标记成蓝色。（关键字详情信息见关键字文档）

## 九、标识符

由数字、字母、下划线_、美元符号$组成，不能以数字开头，不能是关键字。

大驼峰命名法：每个单词的首字母大写，用于接口和类；范例2： GoodStudent

小驼峰命名法：首字母小写，第二个单词起每个单词的首字母大写，用于变量和方法。范例2：firstName

## 十、数据类型

二进制转换网站[二进制转十进制| 2进制转10进制 | 在线进制转换 (sojson.com)](https://www.sojson.com/hexconvert/2to10.html)

### 1.计算机中的数据存储

计算机中最小信息单元叫“位”又称之为“比特位（bit）”，由0和1组成,通常用小写的字母"b"表示。

提示：下面的1b、2b、3b相当于1位数、2位数、3位数，十进制中的一位数是0~9(10个数字)，二位数是0~99（100个数字）。

-    1b(2个数字): 0  1

-    2b(4个数字): 00  01  10  11

-    3b(8个数字): 000  001  010  011  100  101  110  111

计算机中最小的存储单位叫做"字节(byte)"由8个连续的位组成，通常用大写字母"B"表示

   1B=8b(256个数字)：00000000到11111111

存储单位换算：1TB = 1024GB  1GB = 1024MB  1MB = 1024KB  1KB = 1024B  1B(字节) = 8bit 

### 2.Java中的数据类型

（关键字的中文意思）

![1657181706723](typora-user-images\1657181706723.png)

补充解释：

①内存占用单位为B（byte），如关键字byte占用内存为1B=8bit，关键字short占用内存为2B=16bit。

②取值范围有正负，关键字byte取值范围是8位=256（二进制的），short取值范围是16位=65536（二进制的）。

③取值范围排序：

byte<short<int<long<float<double

**注意：**

long内存占用虽然是8位比float多，但是float有小数，小数的取值范围计算不一样，比整数会大很多（具体可自行上网搜）

## 十一、流程控制语句

### 1.if语句格式1

```
格式：
    if (关系表达式) {
        语句体;
    }

执行流程：
    1:首先计算关系表达式的值
    2:如果关系表达式的值为true就执行语句体
    3:如果关系表达式的值为false就不执行语句体
    4:继续执行后面的语句内容
需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b
```

```
public class Test_02if格式1 {
    public static void main(String[] args) {
        System.out.println("开始");

        //定义两个变量
        int a = 10;
        int b = 20;
        //需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b
        b=10;
        if (a == b) {
            System.out.println("a等于b");
        }
        System.out.println("结束");
    }
}
```

### 2.if语句格式3

```
格式：
    if (关系表达式1) {
        语句体1;
    } else if (关系表达式2) {
        语句体2;
    }
    …
    else {
        语句体n+1;
    }


执行流程：
    1:首先计算关系表达式1的值
    2:如果值为true就执行语句体1；如果值为false就计算关系表达式2的值
    3:如果值为true就执行语句体2；如果值为false就计算关系表达式3的值
    4:…
    5:如果没有任何关系表达式为true，就执行语句体n+1。
需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日
```

### 3.switch语句格式

```
格式：
    switch(表达式) {
        case 值1：
        语句体1;
        break;
        case 值2：
        语句体2;
        break;
        …
        default：
        语句体n+1;
        [break;]
    }

格式说明：
    表达式：取值为byte、short、int、char，JDK5以后可以是枚举，JDK7以后可以是String。
    case：后面跟的是要和表达式进行比较的值。
    break：表示中断，结束的意思，用来结束switch语句。
    default：表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。

执行流程：
    首先计算表达式的值。
    依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。
    如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后程序结束掉。
需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日
```

## 十二、循环语句

### 1.for语句

```
格式：
    for(初始化语句;条件判断语句;条件控制语句) {
        循环体语句;
    }

执行流程：
    1:执行初始化语句
    2:执行条件判断语句，看其结果是true还是false
        如果是false，循环结束
        如果是true，继续执行
    3:执行循环体语句
    4:执行条件控制语句
    5:回到2继续
```

### 2.while语句

```
基本格式：
        while(条件判断语句) {
			循环体语句;
		}
完整格式：
    初始化语句;
    while(条件判断语句) {
        循环体语句;
        条件控制语句;
    }

执行流程：
    1:执行初始化语句
    2:执行条件判断语句，看其结果是true还是false
        如果是false，循环结束
        如果是true，继续执行
    3:执行循环体语句
    4:执行条件控制语句
    5:回到2继续
```

### 3.do...while语句

```
基本格式：
    do {
        循环体语句;
    }while(条件判断语句);

完整格式：
    初始化语句;
    do {
        循环体语句;
        条件控制语句;
    }while(条件判断语句);

执行流程：
    1:执行初始化语句
    2:执行循环体语句
    3:执行条件控制语句
    4:执行条件判断语句，看其结果是true还是false
        如果是false，循环结束
        如果是true，继续执行
    5:回到2继续
```

### 4.for、while的不同点

![1658318632723](typora-user-images\1658318632723.png)

## 十三、跳转控制语句

```
continue:用在循环中，满足判断条件的时候，跳过某次循环体内容的执行，继续下一次的执行
break:用在循环中，满足判断条件的时候，终止循环体内容的执行，也就是说结束当前的整个循环
```

```
public class Test_11控制跳转语句 {
	public static void main(String[] args) {
		for(int i = 1; i<=5; i++) {
			if(i%2 == 0) {
				continue;//1 3 5 7 9
                //break;//1
                //System.out.println(i);//2 4 6 8
			}
			System.out.println(i);//1 
		}
	}
}
```

## 十四、随机数

```
作用：
	用于产生一个随机数
使用步骤：
	1:导包
		import java.util.Random;
	2:创建对象
		Random r = new Random();
	3:获取随机数
		int number = r.nextInt(10);
		获取数据的范围：[0,10) 包括0,不包括10
```

```
/*
    	//范围计算方法：
		r.nextInt(x)+y   开始:y  结束:x-1+y
		需求:开始 50  结束100
		y=50
		x-1+y=100
		r.nextInt(51)+50
		 */
```

## 十五、数组

### 1.数组的基本使用

```
定义格式：
    数据类型[] 数组名;(推荐方式)
        举例：int[] arr;
    数据类型 数组名[];
        举例：int arr[];
数组初始化：
    A:所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值
    B:数组初始化
        动态初始化
        静态初始化
动态初始化：
    初始化时只指定数组长度，由系统为数组分配初始值
    格式：数据类型[] 变量名 =  new  数据类型[数组长度];
    范例：int[] arr = new int[3];
静态初始化：
    初始化时指定每个数组元素的初始值，由系统决定数组长度

    格式：数据类型[] 变量名 =  new  数据类型[]{数据1, 数据2, 数据3, ……};
    范例：    int[]   arr =  new      int[]{1, 2, 3};

    简化格式：数据类型[] 变量名 = {数据1, 数据2, 数据3, ……};
    范例：       int[]    arr = {1, 2, 3};
    
    补充：int[] arr = new int[]{1, 2, 3};  中的new代表在堆内存中开辟空间
```

### 2.初始化默认值

数组在初始化时，会为存储空间添加默认值

整数：默认值0

浮点数：默认值0.0

布尔值：默认值false

字符：默认值是空字符

引用数据类型：默认值是null

### 3.内存分配

```
数组(引用类型)赋值，传递的是地址值
两个数组指向同一个地址，一个数组对其内容进行修改，另一个也随之改变。
参考资料:素材\7.多个数组指向相同内存.pptx
```



## 十六、Java中的堆与栈

1.在Java中：声明的对象是先在栈内存中为其分配地址空间，在对其进行实例化后则在堆内存中为其分配地址。
例如：

```
Person p = null ; 只在Stack Memory中为其分配地址空间
p = new Person(); 则在Heap Memory中为其分配内存地址
```

在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，**Java就在栈中为这个变量分配内存空间，**
**当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。**
**堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。**

2.在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。

引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。

而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走(释放掉)。

3.堆就是Java代码可及的内存，是留给开发人员使用的；

非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)方法和构造方法 的代码。

## 十七、数组的遍历

遍历:从头到尾,依次访问数组每一个位置,获取每一个位置的元素.

形式如下: 我们通过数组的下标操作数组,所以for循环变量操作的也是数组下标

开始:开始下标0 结束:结束下标length  如何变化:++

```
for(从下标为0的位置开始 ; 下标的取值 < 数组的长度 ; 下标++){
循环体;
}
```

## 十八、二维数组

### **1.访问元素格式**

```
 //数据类型[][] 变量名 =  new  数据类型[一维数组个数][每个一维数组元素个数];
        int[][] arr1 = new int[2][]; //二维数组里存储了两个null
        /*
        {
            null,
            null
        }
         */
        int[][] arr2 = new int[2][0]; //二维数组里存储了两个一位数组,每个一维数组有0个元素
       /* {
            {},
            {}
        }*/
        int[][] arr3 = new int[2][2]; //二维数组里存储了两个null,每个一维数组有2个元素
        /* {
            {0,0},
            {0,0}
        }*/

        //静态初始化  可以定义长度不同的一维数组。
        //数据类型 [][] 变量名 =  new  数据类型[][] {数据1, 数据2,…}, {数据1, 数据2,…}, ……}
        //int[][] arr4 = new int[][]{
        //        {1, 2},
        //        {3, 4, 5},
        //        {6, 7, 8, 9}
        //};
        //简化格式
        int[][] arr4 = {
                         {1, 2},
                         {3, 4, 5},
                         {6, 7, 8, 9}
                        };
    
```

### 2.遍历通用格

```
for(int i=0;i<arr.length;i++){
	int[] arr2 = arr[i];
	for(int i=0;i<arr2.length;i++){
 		//通过arr[i]方法数组中的每一个元素
	}
}

```

### 3.遍历数组的三种方法

for            for-each,           toString

```
public static void main(String[] args) {
        int[][] arr = {{1, 2}, {4, 5, 6}};

        //遍历二维数组,获取到每一个一维数组
        //for (int i = 0; i < arr.length; i++) {
        //    //获取元素(一维数组)
        //    int[] arr2 = arr[i];
        //    //获取了一维数组,再去遍历一维数组
        //    for (int j = 0; j < arr2.length; j++) {
        //        System.out.println(arr2[j]);
        //    }
        //}

        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.println(arr[i][j]);
            }
        }
```

## 十九、方法

### 1.方法定义和调用

```
方法定义
    定义格式:
        public static 返回值类型 方法名 (形式参数 ) {
            //方法体
            //return 返回值;
        }
    格式解析:
        public static	修饰符，先记住
        返回值类型		方法操作完毕，需要返回结果的数据类型，如不需返回结果,写void
        方法名		    调用方法时候使用的标识(名字)
        形式参数		    由数据类型和变量名组成，多个参数之间用逗号隔开(数据类型1 变量名1,数据类型2 变量名2...)
        方法体		    完成功能的代码块
        return		    作用1，结束方法；作用2，返回结果(返回值)。
        返回值		    返回值类型非void，需要在return后面给出与返回值类型一致的数据作为返回值。
        
        例如：
        public static void getMax() {
        int a = 10;
        int b = 10;

        if (a > b) {
            System.out.println(a);
        } else {
            System.out.println(b);
        }
    }
        public static int getMax4(int a, int b) {
        if (a > b) {
            return a;
        } else {
            return b;
        }
    }
    
方法调用
    使用格式：
        方法名 ( 实际参数) ;
        格式解析:
            方法名	方法定义时的方法名
            实际参数	与形式参数位置对应的数据，调用方法时，会将实际参数赋值给形式参数。
    注意事项
        调用方法时,实际参数的个数与类型要与形参参数个数和类型保持一致。
        传入的参数可以使常量，也可以是变量。
        无返回值的方法，直接调用；有返回值的方法可以直接调用，可以用变量接收结果，可以直接打印返回结果。
    方法调用执行流程
        参考资料:素材\1.方法调用过程.pptx
```

### 2.调用方法时的注意事项

```
void类型的方法，直接调用即可
method3();
非void类型的方法，变量接受/直接打印/单独调用
 boolean b4 = isEvenNum4(101);
        System.out.println(b4);//有返回值的方法，可以用变量b2接收结果
        
        System.out.println(isEvenNum4(11));//直接打印
        
        isEvenNum4(10)//单独调用
```

### 3.方法重载

```
概念：符合下列要求的方法，互称方法重载。
    多个方法在同一个类中
    多个方法具有相同的方法名
    多个方法的参数不相同，类型不同或者数量不同
    与返回值无关
特点
    重载仅对应同一个类中方法的定义，与方法的调用无关，调用方式参照标准格式
    重载仅针对方法的名称与参数识别，与返回值无关
好处
    重载的最直接作用是方便了程序员可以根据不同的参数个数，顺序，类型，自动匹配方法，减少写过个函数名或方法名的重复步骤。
```



```
public class Test_08方法重载 {
    public static void main(String[] args) {
        //调用方法
        System.out.println(getSum(10, 20));
        System.out.println(getSum(10.0, 20.0));
        System.out.println(getSum(10, 20,30));
    }

    //需求1：求两个int类型数据和的方法
    public static int getSum(int a,int b){
        //int sum =a+b;
        //return sum;
        return a+b;
    }

    //需求2：求两个double类型数据和的方法
    public static double getSum(double a,double b){
        return a+b;
    }

    //需求3：求三个int类型数据和的方法
    public static int getSum(int a,int b,int c){
        return a+b+c;
    }
}
```



## 二十、**方法的参数传递**

### 1.基本类型参数传递

对于基本数据类型的参数，形式参数的改变，不影响实际参数的值

```java
public class Test_10基本类型参数传递示例 {
    public static void main(String[] args) {
        int number = 100;
        System.out.println("调用change方法前：" + number);//100
        change(number);
        System.out.println("调用change方法后：" + number);//100

    }

    public static void change(int number) {
        number = 200;
    }
}
```

### 2.**引用类型参数传递**

（1）对于引用类型的参数，形式参数的改变，影响实际参数的值

（2）**String是个特例，不会影响实参改变**

```java
public class Test_11引用类型参数传递示例 {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30};
        System.out.println("调用change方法前：" + arr[1]);//20
        change(arr);
        System.out.println("调用change方法后：" + arr[1]);//200
    }

    public static void change(int[] arr) {
        arr[1] = 200;
    }
}
```



